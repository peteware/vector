#ifndef PW_MEMORY_H // -*- c++ -*-
#define PW_MEMORY_H

#include <pw/internal/meta.h>
#include <pw/internal/ptrdiff.h>
#include <pw/internal/size.h>
#include <pw/internal/bool_type.h>

#include <memory>

namespace pw {

/**
 * The generic template that is used for smart ptrs.
 *
 * The specialization for <Type *> is for real ptrs.
 */
template<class Ptr>
struct pointer_traits
{
    using pointer         = Ptr;
    using element_type    = typename internal::element_type<Ptr>::type;
    using difference_type = typename internal::difference_type<Ptr>::type;

    template<typename U>
    using rebind = typename internal::rebind_ptr<Ptr, U>::type;

    static pointer pointer_to(element_type& r) { return Ptr::pointer_to(r); }
};

/**
 * Specialization for real pointers (Type *)
 */
template<class Type>
struct pointer_traits<Type*>
{
    using pointer         = Type*;
    using element_type    = Type;
    using difference_type = internal::ptrdiff_t;

    template<typename U>
    using rebind = U*;

    static pointer pointer_to(element_type& r) noexcept { return std::addressof(r); };
};

template<class Type>
struct allocator
{
    using value_type                             = Type;
    using size_type                              = internal::size_t;
    using difference_type                        = internal::ptrdiff_t;
    using is_always_equal                        = internal::true_type;
    using propagate_on_container_move_assignment = internal::true_type;
};

} // namespace pw
#endif /* PW_MEMORY_H */
