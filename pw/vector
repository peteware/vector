#ifndef PW_VECTOR_H // -*- c++ -*-
#define PW_VECTOR_H

#include <pw/memory>
#include <pw/memory_resource>

namespace pw {

template<class Type, class Allocator = allocator<Type>>
class vector
{
public:
    using value_type      = Type;
    using allocator_type  = Allocator;
    using size_type       = size_t;
    using difference_type = ptrdiff_t;
    using reference       = value_type&;
    using const_reference = value_type const&;
    using pointer         = typename allocator_traits<Allocator>::pointer;
    using const_pointer   = typename allocator_traits<Allocator>::const_pointer;

    // Default constructor
    vector(allocator_type const& alloc = allocator_type());

    bool      empty() const;
    size_type size() const;
    size_type capacity() const;

    void push_back(Type const& value);
    void push_back(Type&& value);

private:
    pointer               m_begin;
    pointer               m_end;
    pointer               m_bufend;
    allocator_type const& m_alloc;
};

namespace pmr {
template<class Type>
using vector = vector<Type, polymorphic_allocator<Type>>;
}

template<class Type, class Allocator>
vector<Type, Allocator>::vector(allocator_type const& alloc)
    : m_begin()
    , m_end()
    , m_bufend()
    , m_alloc(alloc)
{
}

template<class Type, class Allocator>
bool
vector<Type, Allocator>::empty() const
{
    return m_begin == m_end;
}

template<class Type, class Allocator>
typename vector<Type, Allocator>::size_type
vector<Type, Allocator>::size() const
{
    return m_end - m_begin;
}

template<class Type, class Allocator>
typename vector<Type, Allocator>::size_type
vector<Type, Allocator>::capacity() const
{
    return m_bufend - m_begin;
}

template<class Type, class Allocator>
void
vector<Type, Allocator>::push_back(Type const& value)
{
}

template<class Type, class Allocator>
void
vector<Type, Allocator>::push_back(Type&& value)
{
}

} // namespace pw

#endif /*  PW_VECTOR_H */
