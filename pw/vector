#ifndef PW_VECTOR_H // -*- c++ -*-
#define PW_VECTOR_H

#include <pw/impl/allocator.h>
#include <pw/impl/allocator_traits.h>
#include <pw/impl/iterator_traits.h>
#include <pw/impl/reverse_iterator.h>

#include <initializer_list>

namespace pw {

template<class Type, class Allocator = allocator<Type>>
class vector
{
public:
    using value_type             = Type;
    using allocator_type         = Allocator;
    using size_type              = size_t;
    using difference_type        = ptrdiff_t;
    using reference              = value_type&;
    using const_reference        = value_type const&;
    using pointer                = typename allocator_traits<Allocator>::pointer;
    using const_pointer          = typename allocator_traits<Allocator>::const_pointer;
    using iterator               = typename allocator_traits<Allocator>::pointer;
    using const_iterator         = typename allocator_traits<Allocator>::const_pointer;
    using reverse_iterator       = pw::reverse_iterator<iterator>;
    using const_reverse_iterator = pw::reverse_iterator<iterator const>;

    constexpr vector() noexcept(noexcept(allocator_type()));
    constexpr explicit vector(allocator_type const& alloc) noexcept;
    constexpr vector(size_type count, value_type const& value, allocator_type const& alloc = allocator_type());
    constexpr explicit vector(size_type count, allocator_type const& alloc = allocator_type());
    constexpr vector(vector const& other);
    constexpr vector(vector const& other, allocator_type const& alloc);
    constexpr vector(vector&& other) noexcept;
    constexpr vector(vector&& other, allocator_type const& alloc);
    constexpr vector(std::initializer_list<value_type> init, allocator_type const& alloc = allocator_type());

    template<class Iterator>
    constexpr vector(Iterator first, Iterator last, allocator_type const& alloc = allocator_type());

    constexpr ~vector();

    constexpr vector& operator=(const vector& other);
    constexpr vector& operator=(std::initializer_list<value_type> ilist);
    constexpr vector& operator=(vector&& other) noexcept(
        pw::allocator_traits<allocator_type>::propagate_on_container_move_assignment::value ||
        pw::allocator_traits<allocator_type>::is_always_equal::value);

    constexpr void
    swap(vector& other) noexcept(pw::allocator_traits<allocator_type>::propagate_on_container_swap::value ||
                                 pw::allocator_traits<allocator_type>::is_always_equal::value);

    template<class Iterator>
    constexpr void                   assign(Iterator begin, Iterator end);
    constexpr void                   assign(size_type count, value_type const& value);
    constexpr void                   assign(std::initializer_list<value_type> ilist);
    constexpr allocator_type         get_allocator() const;
    constexpr reference              at(size_type position);
    constexpr const_reference        at(size_type position) const;
    constexpr reference              operator[](size_type position);
    constexpr const_reference        operator[](size_type position) const;
    constexpr reference              front();
    constexpr const_reference        front() const;
    constexpr reference              back();
    constexpr const_reference        back() const;
    constexpr value_type*            data() noexcept;
    constexpr value_type const*      data() const noexcept;
    constexpr iterator               begin() noexcept;
    constexpr iterator               end() noexcept;
    constexpr const_iterator         begin() const noexcept;
    constexpr const_iterator         end() const noexcept;
    constexpr const_iterator         cbegin() const noexcept;
    constexpr const_iterator         cend() const noexcept;
    constexpr reverse_iterator       rbegin() noexcept;
    constexpr reverse_iterator       rend() noexcept;
    constexpr const_reverse_iterator rbegin() const noexcept;
    constexpr const_reverse_iterator rend() const noexcept;
    constexpr const_reverse_iterator crbegin() const noexcept;
    constexpr const_reverse_iterator crend() const noexcept;
    [[nodiscard]] constexpr bool     empty() const noexcept;
    constexpr size_type              size() const noexcept;
    constexpr size_type              max_size() const noexcept;
    constexpr size_type              capacity() const noexcept;
    constexpr void                   shrink_to_fit();
    constexpr void                   reserve(size_type count);
    constexpr void                   clear() noexcept;
    constexpr void                   push_back(const_reference value);
    constexpr void                   push_back(value_type&& value);
    constexpr void                   resize(size_type count);
    constexpr void                   resize(size_type count, const_reference value);
    constexpr iterator               erase(const_iterator position);
    constexpr iterator               erase(const_iterator begin, const_iterator end);
    constexpr void                   pop_back();
    constexpr iterator               insert(const_iterator position, const_reference value);
    constexpr iterator               insert(const_iterator position, value_type&& value);
    constexpr iterator               insert(const_iterator position, size_type count, const_reference value);
    constexpr iterator               insert(const_iterator position, std::initializer_list<value_type> ilist);
    template<class Iterator>
    constexpr iterator insert(const_iterator position, Iterator first, Iterator last);
    template<class... Args>
    constexpr reference emplace_back(Args&&... args);
    template<class... Args>
    constexpr iterator emplace(const_iterator position, Args&&... args);

private:
    static value_type s_value;
};

template<class Type, class Allocator>
typename vector<Type, Allocator>::value_type vector<Type, Allocator>::s_value;

template<class Type, class Allocator>
void constexpr swap(vector<Type, Allocator>& op1,
                    vector<Type, Allocator>& op2) noexcept(noexcept(op1.swap(op2)));

template<class Type, class Allocator>
constexpr bool operator==(const vector<Type, Allocator>& op1, const vector<Type, Allocator>& op2);

template<class Type, class Allocator>
constexpr auto
operator<=>(const vector<Type, Allocator>& op1, const vector<Type, Allocator>& op2) -> decltype(op1[0] <=> op2[0]);

template<class Type, class Allocator>
constexpr vector<Type, Allocator>::vector() noexcept(noexcept(allocator_type()))
{
}

template<class Type, class Allocator>
constexpr vector<Type, Allocator>::vector(allocator_type const& alloc) noexcept
{
    (void)alloc;
}

template<class Type, class Allocator>
constexpr vector<Type, Allocator>::vector(size_type             count,
                                          value_type const&     value,
                                          allocator_type const& alloc)
{
    (void)count;
    (void)value;
    (void)alloc;
}

template<class Type, class Allocator>
constexpr vector<Type, Allocator>::vector(size_type count, allocator_type const& alloc)
{
    (void)count;
    (void)alloc;
}

template<class Type, class Allocator>
constexpr vector<Type, Allocator>::vector(vector const& copy)
{
    (void)copy;
}

template<class Type, class Allocator>
constexpr vector<Type, Allocator>::vector(vector const& copy, allocator_type const& alloc)
{
    (void)copy;
    (void)alloc;
}

template<class Type, class Allocator>
constexpr vector<Type, Allocator>::vector(vector&& other) noexcept
{
    (void)other;
}

template<class Type, class Allocator>
constexpr vector<Type, Allocator>::vector(vector&& other, const Allocator& alloc)
{
    (void)other;
    (void)alloc;
}

template<class Type, class Allocator>
constexpr vector<Type, Allocator>::vector(std::initializer_list<value_type> init, allocator_type const& alloc)
{
    (void)init;
    (void)alloc;
}

template<class Type, class Allocator>
template<class Iterator>
constexpr vector<Type, Allocator>::vector(Iterator first, Iterator last, allocator_type const& alloc)
{
    (void)first;
    (void)last;
    (void)alloc;
}

template<class Type, class Allocator>
constexpr vector<Type, Allocator>::~vector()
{
}

template<class Type, class Allocator>
constexpr void
vector<Type, Allocator>::swap(vector& other) noexcept(
    pw::allocator_traits<allocator_type>::propagate_on_container_swap::value ||
    pw::allocator_traits<allocator_type>::is_always_equal::value)
{
    (void)other;
}

template<class Type, class Allocator>
constexpr vector<Type, Allocator>&
vector<Type, Allocator>::operator=(const vector& other)
{
    (void)other;
    return *this;
}

template<class Type, class Allocator>
constexpr vector<Type, Allocator>&
vector<Type, Allocator>::operator=(std::initializer_list<value_type> ilist)
{
    (void)ilist;
    return *this;
}

template<class Type, class Allocator>
constexpr vector<Type, Allocator>&
vector<Type, Allocator>::operator=(vector&& other) noexcept(
    pw::allocator_traits<allocator_type>::propagate_on_container_move_assignment::value ||
    pw::allocator_traits<allocator_type>::is_always_equal::value)
{
    (void)other;
    return *this;
}

template<class Type, class Allocator>
template<class Iterator>
constexpr void
vector<Type, Allocator>::assign(Iterator begin, Iterator end)
{
    (void)begin;
    (void)end;
}

template<class Type, class Allocator>
constexpr void
vector<Type, Allocator>::assign(size_type count, value_type const& value)
{
    (void)count;
    (void)value;
}

template<class Type, class Allocator>
constexpr void
vector<Type, Allocator>::assign(std::initializer_list<value_type> ilist)
{
    (void)ilist;
}

template<class Type, class Allocator>
constexpr typename vector<Type, Allocator>::allocator_type
vector<Type, Allocator>::get_allocator() const
{
    return Allocator();
}

template<class Type, class Allocator>
constexpr typename vector<Type, Allocator>::reference
vector<Type, Allocator>::at(size_type position)
{
    (void)position;
    return s_value;
}

template<class Type, class Allocator>
constexpr typename vector<Type, Allocator>::const_reference
vector<Type, Allocator>::at(size_type position) const
{
    (void)position;
    return s_value;
}

template<class Type, class Allocator>
constexpr typename vector<Type, Allocator>::reference
vector<Type, Allocator>::operator[](size_type position)
{
    (void)position;
    return s_value;
}

template<class Type, class Allocator>
constexpr typename vector<Type, Allocator>::const_reference
vector<Type, Allocator>::operator[](size_type position) const
{
    (void)position;
    return s_value;
}

template<class Type, class Allocator>
constexpr typename vector<Type, Allocator>::reference
vector<Type, Allocator>::front()
{
    return s_value;
}

template<class Type, class Allocator>
constexpr typename vector<Type, Allocator>::const_reference
vector<Type, Allocator>::front() const
{
    return s_value;
}

template<class Type, class Allocator>
constexpr typename vector<Type, Allocator>::reference
vector<Type, Allocator>::back()
{
    return s_value;
}

template<class Type, class Allocator>
constexpr typename vector<Type, Allocator>::const_reference
vector<Type, Allocator>::back() const
{
    return s_value;
}

template<class Type, class Allocator>
constexpr Type*
vector<Type, Allocator>::data() noexcept
{
    return &s_value;
}

template<class Type, class Allocator>
constexpr Type const*
vector<Type, Allocator>::data() const noexcept
{
    return &s_value;
}

template<class Type, class Allocator>
constexpr typename vector<Type, Allocator>::iterator
vector<Type, Allocator>::begin() noexcept
{
    return &s_value;
}

template<class Type, class Allocator>
constexpr typename vector<Type, Allocator>::iterator
vector<Type, Allocator>::end() noexcept
{
    return &s_value;
}

template<class Type, class Allocator>
constexpr typename vector<Type, Allocator>::const_iterator
vector<Type, Allocator>::begin() const noexcept
{
    return &s_value;
}

template<class Type, class Allocator>
constexpr typename vector<Type, Allocator>::const_iterator
vector<Type, Allocator>::end() const noexcept
{
    return &s_value;
}

template<class Type, class Allocator>
constexpr typename vector<Type, Allocator>::const_iterator
vector<Type, Allocator>::cbegin() const noexcept
{
    return &s_value;
}

template<class Type, class Allocator>
constexpr typename vector<Type, Allocator>::const_iterator
vector<Type, Allocator>::cend() const noexcept
{
    return &s_value;
}

template<class Type, class Allocator>
constexpr typename vector<Type, Allocator>::reverse_iterator
vector<Type, Allocator>::rbegin() noexcept
{
    return reverse_iterator(end());
}

template<class Type, class Allocator>
constexpr typename vector<Type, Allocator>::reverse_iterator
vector<Type, Allocator>::rend() noexcept
{
    return reverse_iterator(begin());
}

template<class Type, class Allocator>
constexpr typename vector<Type, Allocator>::const_reverse_iterator
vector<Type, Allocator>::rbegin() const noexcept
{
    return const_reverse_iterator(end());
}

template<class Type, class Allocator>
constexpr typename vector<Type, Allocator>::const_reverse_iterator
vector<Type, Allocator>::rend() const noexcept
{
    return const_reverse_iterator(begin());
}

template<class Type, class Allocator>
constexpr typename vector<Type, Allocator>::const_reverse_iterator
vector<Type, Allocator>::crbegin() const noexcept
{
    return const_reverse_iterator(end());
}

template<class Type, class Allocator>
constexpr typename vector<Type, Allocator>::const_reverse_iterator
vector<Type, Allocator>::crend() const noexcept
{
    return const_reverse_iterator(begin());
}

template<class Type, class Allocator>
constexpr bool
vector<Type, Allocator>::empty() const noexcept
{
    return true;
}

template<class Type, class Allocator>
constexpr typename vector<Type, Allocator>::size_type
vector<Type, Allocator>::size() const noexcept
{
    return 0;
}

template<class Type, class Allocator>
constexpr typename vector<Type, Allocator>::size_type
vector<Type, Allocator>::max_size() const noexcept
{
    return 1;
}

template<class Type, class Allocator>
constexpr typename vector<Type, Allocator>::size_type
vector<Type, Allocator>::capacity() const noexcept
{
    return 0;
}

template<class Type, class Allocator>
constexpr void
vector<Type, Allocator>::shrink_to_fit()
{
}

template<class Type, class Allocator>
constexpr void
vector<Type, Allocator>::reserve(size_type count)
{
    (void)count;
}

template<class Type, class Allocator>
constexpr void
vector<Type, Allocator>::clear() noexcept
{
}

template<class Type, class Allocator>
constexpr void
vector<Type, Allocator>::push_back(const_reference value)
{
    (void)value;
}

template<class Type, class Allocator>
constexpr void
vector<Type, Allocator>::push_back(value_type&& value)
{
    (void)value;
}

template<class Type, class Allocator>
constexpr void
vector<Type, Allocator>::resize(size_type count)
{
    (void)count;
}

template<class Type, class Allocator>
constexpr void
vector<Type, Allocator>::resize(size_type count, const_reference value)
{
    (void)count;
    (void)value;
}

template<class Type, class Allocator>
constexpr typename vector<Type, Allocator>::iterator
vector<Type, Allocator>::erase(const_iterator position)
{
    return erase(position, position + 1);
}

template<class Type, class Allocator>
constexpr typename vector<Type, Allocator>::iterator
vector<Type, Allocator>::erase(const_iterator begin, const_iterator end)
{
    (void)begin;
    (void)end;
    return &s_value;
}

template<class Type, class Allocator>
constexpr void
vector<Type, Allocator>::pop_back()
{
}

template<class Type, class Allocator>
constexpr typename vector<Type, Allocator>::iterator
vector<Type, Allocator>::insert(const_iterator position, const_reference value)
{
    return insert(position, static_cast<size_type>(1), value);
}

template<class Type, class Allocator>
constexpr typename vector<Type, Allocator>::iterator
vector<Type, Allocator>::insert(const_iterator position, size_type count, const_reference value)
{
    (void)position;
    (void)count;
    (void)value;
    return &s_value;
}

template<class Type, class Allocator>
template<class Iterator>
constexpr typename vector<Type, Allocator>::iterator
vector<Type, Allocator>::insert(const_iterator position, Iterator first, Iterator last)
{
    (void)position;
    (void)first;
    (void)last;
    return &s_value;
}

template<class Type, class Allocator>
template<class... Args>
constexpr typename vector<Type, Allocator>::reference
vector<Type, Allocator>::emplace_back(Args&&... args)
{
    return s_value;
}

template<class Type, class Allocator>
template<class... Args>
constexpr typename vector<Type, Allocator>::iterator
vector<Type, Allocator>::emplace(const_iterator position, Args&&... args)
{
    (void)position;
    return &s_value;
}

template<class Type, class Allocator>
constexpr void
swap(vector<Type, Allocator>& op1, vector<Type, Allocator>& op2) noexcept(noexcept(op1.swap(op2)))
{
    (void)op1;
    (void)op2;
}

template<class Type, class Allocator>
constexpr bool
operator==(const pw::vector<Type, Allocator>& op1, const pw::vector<Type, Allocator>& op2)
{
    if (op1.size() != op2.size())
    {
        return false;
    }
    return (op1 <=> op2) == 0;
}

template<class Type, class Allocator>
constexpr auto
operator<=>(const pw::vector<Type, Allocator>& op1, const pw::vector<Type, Allocator>& op2)
    -> decltype(op1[0] <=> op2[0])
{
    return op1[0] <=> op2[0];
}

} // namespace pw
#endif /*  PW_VECTOR_H */
