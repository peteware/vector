#ifndef PW_VECTOR_H // -*- c++ -*-
#define PW_VECTOR_H

#include <pw/memory>
#include <pw/memory_resource>

namespace pw {

template<class Type, class Allocator = allocator<Type>>
class vector
{
public:
    using value_type      = Type;
    using allocator_type  = Allocator;
    using size_type       = size_t;
    using difference_type = ptrdiff_t;
    using reference       = value_type&;
    using const_reference = value_type const&;
    using pointer         = typename allocator_traits<Allocator>::pointer;
    using const_pointer   = typename allocator_traits<Allocator>::const_pointer;

    // Default constructor
    vector(allocator_type const& alloc = allocator_type());

    bool      empty() const;
    size_type size() const;
    size_type capacity() const;

    void push_back(Type const& value);
    void push_back(Type&& value);

    struct Allocate
    {
        pointer               m_begin;
        pointer               m_end;
        pointer               m_bufend;
        allocator_type const& m_alloc;

        Allocate(allocator_type const& alloc)
            : m_begin()
            , m_end()
            , m_bufend()
            , m_alloc(alloc)
        {
        }

        Allocate(Allocate const& copy)
            : m_begin(copy.m_begin)
            , m_end(copy.m_end)
            , m_bufend(copy.m_bufend)
            , m_alloc(copy.m_alloc)
        {
        }

        ~Allocate() {}
    };

private:
    Allocate m_data;
};

namespace pmr {
template<class Type>
using vector = vector<Type, polymorphic_allocator<Type>>;
}

template<class Type, class Allocator>
vector<Type, Allocator>::vector(allocator_type const& alloc)
    : m_data(alloc)
{
}

template<class Type, class Allocator>
bool
vector<Type, Allocator>::empty() const
{
    return m_data.m_begin == m_data.m_end;
}

template<class Type, class Allocator>
typename vector<Type, Allocator>::size_type
vector<Type, Allocator>::size() const
{
    return m_data.m_end - m_data.m_begin;
}

template<class Type, class Allocator>
typename vector<Type, Allocator>::size_type
vector<Type, Allocator>::capacity() const
{
    return m_data.m_bufend - m_data.m_begin;
}

template<class Type, class Allocator>
void
vector<Type, Allocator>::push_back(Type const& value)
{
}

template<class Type, class Allocator>
void
vector<Type, Allocator>::push_back(Type&& value)
{
}

} // namespace pw

#endif /*  PW_VECTOR_H */
