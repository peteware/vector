#ifndef PW_VECTOR_H // -*- c++ -*-
#define PW_VECTOR_H

#include <pw/internal/storage.h>

#include <pw/impl/allocator_traits.h>
#include <pw/impl/destroy.h>
#include <pw/impl/fill.h>
#include <pw/impl/for_each.h>
#include <pw/impl/iterator_traits.h>
#include <pw/impl/move_backward.h>
#include <pw/impl/uninitialized_copy.h>
#include <pw/impl/uninitialized_default_construct.h>
#include <pw/impl/uninitialized_fill.h>
#include <pw/impl/uninitialized_move.h>

#include <limits>
#include <stdexcept>

namespace pw {

template<class Type, class Allocator = allocator<Type>>
class vector
{
public:
    using value_type      = Type;
    using allocator_type  = Allocator;
    using size_type       = size_t;
    using difference_type = ptrdiff_t;
    using reference       = value_type&;
    using const_reference = value_type const&;
    using pointer         = typename allocator_traits<Allocator>::pointer;
    using const_pointer   = typename allocator_traits<Allocator>::const_pointer;
    using iterator        = typename allocator_traits<Allocator>::pointer;
    using const_iterator  = typename allocator_traits<Allocator>::const_pointer;

    explicit vector(allocator_type const& alloc = allocator_type());
    explicit vector(size_type count);
    vector(size_type count, value_type const& value, allocator_type const& alloc = allocator_type());
    vector(vector const& copy);
    vector(vector const& copy, allocator_type const& alloc);
    ~vector();

    allocator_type    get_allocator() const;
    reference         at(size_type position);
    const_reference   at(size_type position) const;
    reference         operator[](size_type position);
    const_reference   operator[](size_type position) const;
    reference         front();
    const_reference   front() const;
    reference         back();
    const_reference   back() const;
    value_type*       data() noexcept;
    value_type const* data() const noexcept;
    iterator          begin() noexcept;
    iterator          end() noexcept;
    const_iterator    begin() const noexcept;
    const_iterator    end() const noexcept;
    const_iterator    cbegin() const noexcept;
    const_iterator    cend() const noexcept;
    bool              empty() const;
    size_type         size() const;
    size_type         max_size() const;
    size_type         capacity() const;
    void              shrink_to_fit();
    void              reserve(size_type count);
    void              clear() noexcept;
    void              push_back(Type const& value);
    void              push_back(Type&& value);
    void              resize(size_type count);
    void              resize(size_type count, value_type const& value);
    iterator          insert(const_iterator position, value_type const& value);
    iterator          insert(const_iterator position, size_type count, value_type const& value);

private:
    internal::Storage<Type, Allocator> m_data;
};

// namespace pmr {
// template<class Type>
// using vector = vector<Type, pmr::polymorphic_allocator<Type>>;
// }

template<class Type, class Allocator>
vector<Type, Allocator>::vector(allocator_type const& alloc)
    : m_data(alloc)
{
}

template<class Type, class Allocator>
vector<Type, Allocator>::vector(size_type count)
    : m_data(count, allocator_type())
{
    m_data.set_size(count);
    pw::uninitialized_default_construct(m_data.begin(), m_data.end());
}

template<class Type, class Allocator>
vector<Type, Allocator>::vector(size_type count, value_type const& value, allocator_type const& alloc)
    : m_data(count, alloc)
{
    m_data.set_size(count);
    pw::uninitialized_fill(m_data.begin(), m_data.end(), value);
}

template<class Type, class Allocator>
vector<Type, Allocator>::vector(vector const& copy)
    : m_data(copy.m_data)
{
}

template<class Type, class Allocator>
vector<Type, Allocator>::~vector()
{
}

template<class Type, class Allocator>
typename vector<Type, Allocator>::allocator_type
vector<Type, Allocator>::get_allocator() const
{
    return m_data.m_alloc;
}

template<class Type, class Allocator>
typename vector<Type, Allocator>::reference
vector<Type, Allocator>::at(size_type position)
{
    if (position >= size())
    {
        throw std::out_of_range("position out of range");
    }
    return *(m_data.m_begin + position);
}

template<class Type, class Allocator>
typename vector<Type, Allocator>::const_reference
vector<Type, Allocator>::at(size_type position) const
{
    if (position >= size())
    {
        throw std::out_of_range("position out of range");
    }
    return *(m_data.m_begin + position);
}

template<class Type, class Allocator>
typename vector<Type, Allocator>::reference vector<Type, Allocator>::operator[](size_type position)
{
    return *(m_data.m_begin + position);
}

template<class Type, class Allocator>
typename vector<Type, Allocator>::const_reference
    vector<Type, Allocator>::operator[](size_type position) const
{
    return *(m_data.m_begin + position);
}

template<class Type, class Allocator>
typename vector<Type, Allocator>::reference
vector<Type, Allocator>::front()
{
    return *m_data.m_begin;
}

template<class Type, class Allocator>
typename vector<Type, Allocator>::const_reference
vector<Type, Allocator>::front() const
{
    return *m_data.m_begin;
}

template<class Type, class Allocator>
typename vector<Type, Allocator>::reference
vector<Type, Allocator>::back()
{
    return *(m_data.m_end - 1);
}

template<class Type, class Allocator>
typename vector<Type, Allocator>::const_reference
vector<Type, Allocator>::back() const
{
    return *(m_data.m_end - 1);
}

template<class Type, class Allocator>
Type*
vector<Type, Allocator>::data() noexcept
{
    return m_data.m_begin;
}

template<class Type, class Allocator>
Type const*
vector<Type, Allocator>::data() const noexcept
{
    return m_data.m_begin;
}

template<class Type, class Allocator>
typename vector<Type, Allocator>::iterator
vector<Type, Allocator>::begin() noexcept
{
    return m_data.m_begin;
}

template<class Type, class Allocator>
typename vector<Type, Allocator>::iterator
vector<Type, Allocator>::end() noexcept
{
    return m_data.m_end;
}

template<class Type, class Allocator>
typename vector<Type, Allocator>::const_iterator
vector<Type, Allocator>::begin() const noexcept
{
    return m_data.m_begin;
}

template<class Type, class Allocator>
typename vector<Type, Allocator>::const_iterator
vector<Type, Allocator>::end() const noexcept
{
    return m_data.m_end;
}

template<class Type, class Allocator>
typename vector<Type, Allocator>::const_iterator
vector<Type, Allocator>::cbegin() const noexcept
{
    return m_data.m_begin;
}

template<class Type, class Allocator>
typename vector<Type, Allocator>::const_iterator
vector<Type, Allocator>::cend() const noexcept
{
    return m_data.m_end;
}

template<class Type, class Allocator>
bool
vector<Type, Allocator>::empty() const
{
    return m_data.m_begin == m_data.m_end;
}

template<class Type, class Allocator>
typename vector<Type, Allocator>::size_type
vector<Type, Allocator>::size() const
{
    return m_data.size();
}

template<class Type, class Allocator>
typename vector<Type, Allocator>::size_type
vector<Type, Allocator>::max_size() const
{
    return std::numeric_limits<size_type>::max() / sizeof(Type);
}

template<class Type, class Allocator>
typename vector<Type, Allocator>::size_type
vector<Type, Allocator>::capacity() const
{
    return m_data.capacity();
}

template<class Type, class Allocator>
void
vector<Type, Allocator>::reserve(size_type count)
{
    if (count > capacity())
    {
        m_data = m_data.move(count);
    }
}

template<class Type, class Allocator>
void
vector<Type, Allocator>::shrink_to_fit()
{
    if (size() == capacity())
    {
        return;
    }
    if (empty())
    {
        m_data = internal::Storage<Type, Allocator>(get_allocator());
    }
    else
    {
        m_data = m_data.move(size());
    }
}

template<class Type, class Allocator>
void
vector<Type, Allocator>::clear() noexcept
{
    m_data = internal::Storage<Type, Allocator>(get_allocator());
}

template<class Type, class Allocator>
void
vector<Type, Allocator>::push_back(Type const& value)
{
    if (m_data.capacity() == m_data.size())
    {
        size_type newcount = m_data.newsize();
        m_data             = m_data.move(newcount);
    }
    m_data.push_back(value);
}

template<class Type, class Allocator>
void
vector<Type, Allocator>::push_back(Type&& value)
{
    if (!m_data.hascapacity())
    {
        size_type newcount = m_data.newsize();
        m_data             = m_data.move(newcount);
    }
    m_data.push_back(pw::move(value));
}

template<class Type, class Allocator>
void
vector<Type, Allocator>::resize(size_type count)
{
    if (m_data.size() > count)
    {
        // TODO: need unit test for this bug: pw::destroy(m_data.m_begin, m_data.m_begin + count);
        pw::destroy(m_data.m_begin + count, m_data.m_end);
        m_data.set_size(count);
    }
    else if (m_data.size() < count)
    {
        m_data = m_data.move(count);
        pw::uninitialized_default_construct(m_data.m_end, m_data.m_begin + count);
        m_data.set_size(count);
    }
}

template<class Type, class Allocator>
void
vector<Type, Allocator>::resize(size_type count, value_type const& value)
{
    if (m_data.size() > count)
    {
        pw::destroy(m_data.m_begin + count, m_data.m_end);
        m_data.set_size(count);
    }
    else if (m_data.size() < count)
    {
        m_data = m_data.move(count);
        pw::uninitialized_fill(m_data.m_end, m_data.m_begin + count, value);
        m_data.set_size(count);
    }
}

template<class Type, class Allocator>
typename vector<Type, Allocator>::iterator
vector<Type, Allocator>::insert(const_iterator position, value_type const& value)
{
    difference_type offset  = position - m_data.begin();
    size_type       oldsize = m_data.size();

    if (!m_data.hascapacity())
    {
        m_data = m_data.move(m_data.newsize());
    }
    pw::uninitialized_move(m_data.end() - 1, m_data.end(), m_data.end());
    pw::move_backward(m_data.begin() + offset, m_data.end(), m_data.end());
    m_data.begin()[offset] = pw::move(value);
    m_data.set_size(oldsize + 1);
    return m_data.begin() + offset;
}

template<class Type, class Allocator>
typename vector<Type, Allocator>::iterator
vector<Type, Allocator>::insert(const_iterator position, size_type count, value_type const& value)
{
    difference_type offset = position - m_data.begin();

    if (!m_data.hascapacity(count))
    {
        m_data = m_data.move(m_data.size() + count);
    }

    /*
     * Here are two illustrative scenarios.  A blank box means
     * it is uninitialized; a "?" means it is initialized
     * but contents undefined (e.g. it was move'd).
     *    
     *          Scenario 1                                  Scenario 2
     *
     * This is how we start:
     *
     *          position                                        position                 
     *              │                                               │                    
     *  count = 2   │               offset = 2      count = 2       │       offset = 3   
     *  value = 5   ▼                               value = 5       ▼                    
     *    ┌────┬────┬────┬────┬────┬────┬────┐       ┌────┬────┬────┬────┬────┬────┬────┐
     * ┌─▶│ 1  │ 2  │ 3  │ 4  │    │    │    │    ┌─▶│ 1  │ 2  │ 3  │ 4  │    │    │    │
     * │  └────┴────┴────┴────┴────┴────┴────┘    │  └────┴────┴────┴────┴────┴────┴────┘
     * │                      ▲                   │                      ▲               
     * │    m_allocated = 7   │                   │    m_allocated = 7   │               
     * │                    m_end                 │                      │               
     * └─── m_begin                               └─── m_begin         m_end             
     *                                                                                   
     */

    /*
     * Intermediate as we make room
     *          position                                        position                 
     *              │                                               │                    
     *  count = 2   │               offset = 2     count = 2        │       offset = 3   
     *  value = 5   ▼                              value = 5        ▼    move_cons = 1   
     *    ┌────┬────┬────┬────┬────┬────┬────┐       ┌────┬────┬────┬────┬────┬────┬────┐
     * ┌─▶│ 1  │ 2  │ ?  │ ?  │ 3  │ 4  │    │    ┌─▶│ 1  │ 2  │ 3  │ ?  │    │ 4  │    │
     * │  └────┴────┴────┴────┴────┴────┴────┘    │  └────┴────┴────┴────┴────┴────┴────┘
     * │                      ▲                   │                      ▲               
     * │    m_allocated = 7   │                   │    m_allocated = 7   │               
     * │                      │                   │                      │               
     * └─── m_begin         m_end                 └─── m_begin         m_end             
     */

    /*                                                                                   
     * Finally
     *                                                                                   
     *          position                                       position                  
     *              │                                              │                     
     *  count = 2   │               offset = 2     count = 2       │       offset = 3    
     *  value = 5   ▼                              value = 5       ▼                     
     *    ┌────┬────┬────┬────┬────┬────┬────┐      ┌────┬────┬────┬────┬────┬────┬────┐ 
     * ┌─▶│ 1  │ 2  │ 5  │ 5  │ 3  │ 4  │    │   ┌─▶│ 1  │ 2  │ 3  │ 5  │ 5  │ 4  │    │ 
     * │  └────┴────┴────┴────┴────┴────┴────┘   │  └────┴────┴────┴────┴────┴────┴────┘ 
     * │                                ▲        │                                ▲      
     * │    m_allocated = 7             │        │    m_allocated = 7             │      
     * │                                │        │                                │      
     * └─── m_begin                   m_end      └─── m_begin                   m_end    
     *                                                                                   
     */
    size_type oldsize  = m_data.size();
    size_type movecons = pw::min(count, oldsize - offset);
    size_type copycons = count - movecons;
    iterator  newpos   = m_data.begin() + offset;
    /*
     * Deal with unitialized memory
     * - Move existing values into uninitialized memory
     * - Copy construct value into uninitialized memory
     */
    pw::uninitialized_move(m_data.end() - movecons, m_data.end(), m_data.end() + copycons);
    pw::uninitialized_fill(m_data.end(), m_data.end() + copycons, value);
    /*
     * Already constructed
     * - Move existing values into new location
     * - Copy construct value into place
     * - Set m_end
     */
    pw::move_backward(newpos, newpos + count, m_data.end());
    pw::fill(newpos, newpos + count, value);
    m_data.set_size(oldsize + count);
    return newpos;
}

} // namespace pw

#endif /*  PW_VECTOR_H */
