#ifndef PW_VECTOR_H // -*- c++ -*-
#define PW_VECTOR_H

#include <pw/memory>
#include <pw/memory_resource>

namespace pw {

template<class Type, class Allocator = allocator<Type>>
class vector
{
public:
    using value_type      = Type;
    using allocator_type  = Allocator;
    using size_type       = size_t;
    using difference_type = ptrdiff_t;
    using reference       = value_type&;
    using const_reference = value_type const&;
    using pointer         = typename allocator_traits<Allocator>::pointer;
    using const_pointer   = typename allocator_traits<Allocator>::const_pointer;

    // Default constructor
    vector(allocator_type const& alloc = allocator_type());

    bool      empty() const;
    size_type size() const;
    size_type capacity() const;

    void push_back(Type const& value);
    void push_back(Type&& value);

private:
    Allocate m_data;
};

namespace pmr {
template<class Type>
using vector = vector<Type, polymorphic_allocator<Type>>;
}

template<class Type, class Allocator>
vector<Type, Allocator>::vector(allocator_type const& alloc)
    : m_data(alloc)
{
}

template<class Type, class Allocator>
bool
vector<Type, Allocator>::empty() const
{
    return m_data.m_begin == m_data.m_end;
}

template<class Type, class Allocator>
typename vector<Type, Allocator>::size_type
vector<Type, Allocator>::size() const
{
    return m_data.size();
}

struct SaveAlloc
{
    Allocate& m_orig;
    Allocate  m_new;

    SaveAlloc(Allocate& orig)
        : m_orig(orig)
        , m_new(orig)
    {
    }
    void done() { m_new.swap(m_orig); }

    ~SaveAlloc() { m_orig.swap(m_new); }
};

template<class Type, class Allocator>
typename vector<Type, Allocator>::size_type
vector<Type, Allocator>::capacity() const
{
    return m_data.m_allocated;
}

template<class Type, class Allocator>
void
vector<Type, Allocator>::push_back(Type const& value)
{
    SaveAllocate space(m_data);

    if (!m_data.hasroom(1))
    {
        Allocate save(m_data);
        save.resize();
        m_data.swap(save);
    }
}

template<class Type, class Allocator>
void
vector<Type, Allocator>::push_back(Type&& value)
{
}

} // namespace pw

#endif /*  PW_VECTOR_H */
