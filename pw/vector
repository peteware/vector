#ifndef PW_VECTOR_H // -*- c++ -*-
#define PW_VECTOR_H

#include <pw/internal/allocate.h>

#include <pw/impl/destroy.h>
#include <pw/impl/for_each.h>
#include <pw/impl/uninitialized_copy.h>
#include <pw/impl/uninitialized_default_construct.h>
#include <pw/impl/uninitialized_fill.h>

#include <limits>
#include <stdexcept>

namespace pw {

template<class Type, class Allocator = allocator<Type>>
class vector
{
public:
    using value_type      = Type;
    using allocator_type  = Allocator;
    using size_type       = size_t;
    using difference_type = ptrdiff_t;
    using reference       = value_type&;
    using const_reference = value_type const&;
    using pointer         = typename allocator_traits<Allocator>::pointer;
    using const_pointer   = typename allocator_traits<Allocator>::const_pointer;

    explicit vector(allocator_type const& alloc = allocator_type());
    explicit vector(size_type count);
    vector(size_type count, value_type const& value, allocator_type const& alloc = allocator_type());
    vector(vector const& copy);
    vector(vector const& copy, allocator_type const& alloc);
    ~vector();

    allocator_type    get_allocator() const;
    reference         at(size_type position);
    const_reference   at(size_type position) const;
    reference         operator[](size_type position);
    const_reference   operator[](size_type position) const;
    reference         front();
    const_reference   front() const;
    reference         back();
    const_reference   back() const;
    value_type*       data() noexcept;
    value_type const* data() const noexcept;
    bool              empty() const;
    size_type         size() const;
    size_type         max_size() const;
    size_type         capacity() const;
    void              reserve(size_type count);
    void              push_back(Type const& value);
    void              push_back(Type&& value);
    void              resize(size_type count);
    void              resize(size_type count, value_type const& value);

private:
    internal::Allocate<Type, Allocator> m_data;
};

// namespace pmr {
// template<class Type>
// using vector = vector<Type, pmr::polymorphic_allocator<Type>>;
// }

template<class Type, class Allocator>
vector<Type, Allocator>::vector(allocator_type const& alloc)
    : m_data(alloc)
{
}

template<class Type, class Allocator>
vector<Type, Allocator>::vector(size_type count)
    : m_data(allocator_type())
{
    m_data.allocate(count).setsize(count);
    pw::for_each(m_data.m_begin, m_data.m_end, [=](value_type& v) {
        allocator_traits<Allocator>::construct(m_data.m_alloc, &v);
    });
}

template<class Type, class Allocator>
vector<Type, Allocator>::vector(size_type count, value_type const& value, allocator_type const& alloc)
    : m_data(alloc)
{
    m_data.allocate(count).setsize(count);
    pw::for_each(m_data.m_begin, m_data.m_end, [=](value_type& v) {
        allocator_traits<Allocator>::construct(m_data.m_alloc, &v, value);
    });
}

template<class Type, class Allocator>
vector<Type, Allocator>::vector(vector const& copy)
    : m_data(copy.m_data)
{
}

template<class Type, class Allocator>
vector<Type, Allocator>::~vector()
{
    pw::destroy(m_data.m_begin, m_data.m_end);
}

template<class Type, class Allocator>
typename vector<Type, Allocator>::allocator_type
vector<Type, Allocator>::get_allocator() const
{
    return m_data.m_alloc;
}

template<class Type, class Allocator>
typename vector<Type, Allocator>::reference
vector<Type, Allocator>::at(size_type position)
{
    if (position >= size())
    {
        throw std::out_of_range("position out of range");
    }
    return *(m_data.m_begin + position);
}

template<class Type, class Allocator>
typename vector<Type, Allocator>::const_reference
vector<Type, Allocator>::at(size_type position) const
{
    if (position >= size())
    {
        throw std::out_of_range("position out of range");
    }
    return *(m_data.m_begin + position);
}

template<class Type, class Allocator>
typename vector<Type, Allocator>::reference vector<Type, Allocator>::operator[](size_type position)
{
    return *(m_data.m_begin + position);
}

template<class Type, class Allocator>
typename vector<Type, Allocator>::const_reference
    vector<Type, Allocator>::operator[](size_type position) const
{
    return *(m_data.m_begin + position);
}

template<class Type, class Allocator>
typename vector<Type, Allocator>::reference
vector<Type, Allocator>::front()
{
    return *m_data.m_begin;
}

template<class Type, class Allocator>
typename vector<Type, Allocator>::const_reference
vector<Type, Allocator>::front() const
{
    return *m_data.m_begin;
}

template<class Type, class Allocator>
typename vector<Type, Allocator>::reference
vector<Type, Allocator>::back()
{
    return *(m_data.m_end - 1);
}

template<class Type, class Allocator>
typename vector<Type, Allocator>::const_reference
vector<Type, Allocator>::back() const
{
    return *(m_data.m_end - 1);
}

template<class Type, class Allocator>
Type*
vector<Type, Allocator>::data() noexcept
{
    return m_data.m_begin;
}

template<class Type, class Allocator>
Type const*
vector<Type, Allocator>::data() const noexcept
{
    return m_data.m_begin;
}

template<class Type, class Allocator>
bool
vector<Type, Allocator>::empty() const
{
    return m_data.m_begin == m_data.m_end;
}

template<class Type, class Allocator>
typename vector<Type, Allocator>::size_type
vector<Type, Allocator>::size() const
{
    return m_data.size();
}

template<class Type, class Allocator>
typename vector<Type, Allocator>::size_type
vector<Type, Allocator>::max_size() const
{
    return std::numeric_limits<size_type>::max() / sizeof(Type);
}

template<class Type, class Allocator>
typename vector<Type, Allocator>::size_type
vector<Type, Allocator>::capacity() const
{
    return m_data.capacity();
}

template<class Type, class Allocator>
void
vector<Type, Allocator>::reserve(size_type count)
{
    if (count > capacity())
    {
        m_data.allocate(count);
    }
}

template<class Type, class Allocator>
void
vector<Type, Allocator>::push_back(Type const& value)
{
    if (!m_data.hasroom(1))
    {
        m_data.expand();
    }
    m_data.add(value);
}

template<class Type, class Allocator>
void
vector<Type, Allocator>::push_back(Type&& value)
{
    if (!m_data.hasroom(1))
    {
        m_data.expand();
    }
    m_data.add(value);
}

template<class Type, class Allocator>
void
vector<Type, Allocator>::resize(size_type count)
{
    if (m_data.size() > count)
    {
        // TODO: need unit test for this bug: pw::destroy(m_data.m_begin, m_data.m_begin + count);
        pw::destroy(m_data.m_begin + count, m_data.m_end);
        m_data.setsize(count);
    }
    else if (m_data.size() < count)
    {
        m_data.allocate(count);
        pw::uninitialized_default_construct(m_data.m_end, m_data.m_begin + count);
        m_data.setsize(count);
    }
}

template<class Type, class Allocator>
void
vector<Type, Allocator>::resize(size_type count, value_type const& value)
{
    if (m_data.size() > count)
    {
        pw::destroy(m_data.m_begin + count, m_data.m_end);
        m_data.setsize(count);
    }
    else if (m_data.size() < count)
    {
        m_data.allocate(count);
        pw::uninitialized_fill(m_data.m_end, m_data.m_begin + count, value);
        m_data.setsize(count);
    }
}
} // namespace pw

#endif /*  PW_VECTOR_H */
